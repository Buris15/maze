<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Maze</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> 
<link rel="stylesheet" href="style.css">
</head>

<body>

<div id="hud">
  ðŸŸ¡ <span id="keyY">0</span>
  ðŸ”´ <span id="keyR">0</span>
  ðŸ”µ <span id="keyB">0</span>
  ðŸšª <span id="doorCount">0</span>
</div>

<div id="gameContainer">
  <div id="game">
    <div id="messageBanner"></div>
  </div>
</div>

<div id="controls">
  <div></div>
  <div class="ctrl" data-dir="up">â–²</div>
  <div></div>
  <div class="ctrl" data-dir="left">â—€</div>
  <div></div>
  <div class="ctrl" data-dir="right">â–¶</div>
  <div></div>
  <div class="ctrl" data-dir="down">â–¼</div>
  <div></div>
</div>

<!-- SOUND EFFECTS -->
<audio id="keySound" src="key.mp3"></audio>
<audio id="doorSound" src="door.mp3"></audio>
<audio id="hitSound" src="hit.mp3"></audio>
<audio id="winSound" src="win.mp3"></audio>

<script>
const rows = 20;
const cols = 25;
let TILE = window.innerWidth <= 768 ? 24 : 32;

const game=document.getElementById("game");
const banner=document.getElementById("messageBanner");

let keys={yellow:0,red:0,blue:0};
let gameWon=false;
let flowersCollected=0;

/* CONFIGURABLE BOOK MESSAGES */
const bookMessages={
  10:"ðŸ“– Book of Beginnings: Every maze has a reasonâ€¦ mine was to find you.",
  11:"ðŸ“– Book of Hearts: The real key was never yellow, red, or blueâ€¦ it was love.",
  12:"ðŸ“– Book of Escape: I searched for the exit, but the only place I want to be is with you."
};

let maze=[
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,0,5,0,1,0,7,0,9,1,0,0,0,1,0,0,0,10,0,0,0,0,0,0,1],
[1,0,1,0,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1],
[1,0,1,0,0,0,0,1,0,0,0,0,0,2,0,0,0,1,0,0,11,1,0,0,1],
[1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1],
[1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],
[1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,6,1,1,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1],
[1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
[1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,8,1,1,1,1,1,1],
[1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
[1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,3,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

let totalDoors=maze.flat().filter(v=>[2,6,8].includes(v)).length;
let player={x:1,y:1};
const playerDiv=document.createElement("div");
playerDiv.className="player";
game.appendChild(playerDiv);

// ---------- GRID & TILE SIZE FUNCTIONS ----------
function updateGridSize(){
  const w = window.innerWidth;
  TILE = w <= 425 ? 16 : w <= 768 ? 20 : 25;
  game.style.gridTemplateColumns = `repeat(${cols}, ${TILE}px)`;
  game.style.gridTemplateRows = `repeat(${rows}, ${TILE}px)`;
  document.querySelectorAll(".cell").forEach(c=>{
    c.style.width = TILE + "px";
    c.style.height = TILE + "px";
  });
  playerDiv.style.width=(TILE-4)+"px";
  playerDiv.style.height=(TILE-4)+"px";
}

// ---------- DRAW ----------
function draw(){
  game.querySelectorAll(".cell").forEach(c=>c.remove());
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const c=document.createElement("div");
      c.className="cell";
      const v=maze[y][x];
      if(v===1)c.innerHTML='<img src="BLOCK.jpg" class="wallImg">';
      if(v===2)c.classList.add("door-yellow");
      if(v===6)c.classList.add("door-red");
      if(v===8)c.classList.add("door-blue");
      if(v===3)c.classList.add("exit");
      if(bookMessages[v]) c.innerHTML='<img src="BOOK.png" style="width:40px;height:40px;display:block;margin:auto;transform:translateY(-6px);">';
      if(v===5)c.innerHTML='<img src="flower-yellow.png" style="width:28px;height:28px;display:block;margin:auto;">';
      if(v===7)c.innerHTML='<img src="flower-red.png" style="width:28px;height:28px;display:block;margin:auto;">';
      if(v===9)c.innerHTML='<img src="flower-blue.png" style="width:28px;height:28px;display:block;margin:auto;">';
      game.appendChild(c);
    }
  }
  playerDiv.style.transform=`translate(${player.x*TILE}px,${player.y*TILE}px)`;
  document.getElementById("keyY").textContent=keys.yellow;
  document.getElementById("keyR").textContent=keys.red;
  document.getElementById("keyB").textContent=keys.blue;
  document.getElementById("doorCount").textContent=totalDoors;
  centerOnPlayer();
  updateGridSize();
  drawEnemies();
}

// ---------- CENTER ----------
function centerOnPlayer(){
  const container=document.getElementById("gameContainer");
  const containerWidth=container.clientWidth;
  const containerHeight=container.clientHeight;
  const mapWidth=cols*TILE;
  const mapHeight=rows*TILE;
  let offsetX=containerWidth/2-(player.x*TILE+TILE/2);
  let offsetY=containerHeight/2-(player.y*TILE+TILE/2);
  offsetX=Math.min(0,Math.max(offsetX,containerWidth-mapWidth));
  offsetY=Math.min(0,Math.max(offsetY,containerHeight-mapHeight));
  game.style.transform=`translate(${offsetX}px,${offsetY}px)`;
}

// ---------- MOVE ----------
function move(dir){
  if(gameWon)return;
  let nx=player.x, ny=player.y;
  if(dir==="up")ny--; if(dir==="down")ny++; if(dir==="left")nx--; if(dir==="right")nx++;
  const t=maze[ny]?.[nx];
  if(t===undefined||t===1)return;

  if(t===5){keys.yellow++; maze[ny][nx]=0; document.getElementById("keySound").play();}
  if(t===7){keys.red++; maze[ny][nx]=0; document.getElementById("keySound").play();}
  if(t===9){keys.blue++; maze[ny][nx]=0; document.getElementById("keySound").play();}

  if(t===2 && keys.yellow<=0) return;
  if(t===6 && keys.red<=0) return;
  if(t===8 && keys.blue<=0) return;

  if(t===2){keys.yellow--; maze[ny][nx]=0; totalDoors--; document.getElementById("doorSound").play();}
  if(t===6){keys.red--; maze[ny][nx]=0; totalDoors--; document.getElementById("doorSound").play();}
  if(t===8){keys.blue--; maze[ny][nx]=0; totalDoors--; document.getElementById("doorSound").play();}

  if(bookMessages[t]){
    banner.textContent=bookMessages[t];
    banner.style.display="block";
    setTimeout(()=>banner.style.display="none",2500);
    maze[ny][nx]=0;
  }

  if(t===3){
   window.location.href = "https://maze-valentine.vercel.app/valentine-success.html";
}

  player.x=nx; player.y=ny;
  draw();
}

// ---------- EVENT LISTENERS ----------
document.addEventListener("keydown",e=>{
  if(e.key==="ArrowUp")move("up");
  if(e.key==="ArrowDown")move("down");
  if(e.key==="ArrowLeft")move("left");
  if(e.key==="ArrowRight")move("right");
});

document.querySelectorAll(".ctrl").forEach(btn=>{
  btn.addEventListener("touchstart",e=>{
    e.preventDefault();
    move(btn.dataset.dir);
  });
});

window.addEventListener("resize", ()=>{ updateGridSize(); centerOnPlayer(); });

// ---------- FALLING IMAGES ----------
const fallingImages=["heart.png"];
const container=document.getElementById("gameContainer");
function createFallingImage(){
  const img=document.createElement("img");
  img.src=fallingImages[Math.floor(Math.random()*fallingImages.length)];
  img.style.position="absolute";
  img.style.width=`${20+Math.random()*20}px`;
  img.style.left=`${Math.random()*container.clientWidth}px`;
  img.style.top=`-${Math.random()*100}px`;
  img.style.zIndex="1";
  img.style.pointerEvents="none";
  container.appendChild(img);
  const speed=1+Math.random()*2;
  function fall(){
    const top=parseFloat(img.style.top);
    if(top<container.clientHeight){ img.style.top=top+speed+"px"; requestAnimationFrame(fall); }
    else img.remove();
  }
  fall();
}
setInterval(createFallingImage,300);

// ---------- INITIAL DRAW ----------
updateGridSize();
draw();
</script>

</body>
</html>
